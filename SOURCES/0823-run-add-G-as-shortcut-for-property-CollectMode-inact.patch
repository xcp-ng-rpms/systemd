From c2975479c63cafea5a5f0254f4525136244f3301 Mon Sep 17 00:00:00 2001
From: Lennart Poettering <lennart@poettering.net>
Date: Mon, 13 Nov 2017 17:17:53 +0100
Subject: [PATCH] run: add "-G" as shortcut for
 "--property=CollectMode=inactive-or-failed"

This option is likely to be very useful for systemd-run invocations,
hence let's add a shortcut for it.

With this new concepts it's now very easy to put together systemd-run
invocations that leave zero artifacts in the system, including when they
fail.

(cherry-picked from commit fe9d0be90ba142bf06d43a831d8be53283415caa)

Related: #1817576
---
 man/systemd-run.xml | 15 +++++++++++++++
 src/run/run.c       | 15 ++++++++++++++-
 2 files changed, 29 insertions(+), 1 deletion(-)

diff --git a/man/systemd-run.xml b/man/systemd-run.xml
index f46fc3abf4..97cf2879eb 100644
--- a/man/systemd-run.xml
+++ b/man/systemd-run.xml
@@ -294,6 +294,21 @@
         <command>set-property</command> command.</para> </listitem>
       </varlistentry>
 
+      <varlistentry>
+        <term><option>-G</option></term>
+        <term><option>--collect</option></term>
+
+        <listitem><para>Unload the transient unit after it completed, even if it failed. Normally, without this option,
+        all units that ran and failed are kept in memory until the user explicitly resets their failure state with
+        <command>systemctl reset-failed</command> or an equivalent command. On the other hand, units that ran
+        successfully are unloaded immediately. If this option is turned on the "garbage collection" of units is more
+        aggressive, and unloads units regardless if they exited successfully or failed. This option is a shortcut for
+        <command>--property=CollectMode=inactive-or-failed</command>, see the explanation for
+        <varname>CollectMode=</varname> in
+        <citerefentry><refentrytitle>systemd.unit</refentrytitle><manvolnum>5</manvolnum></citerefentry> for further
+        information.</para></listitem>
+      </varlistentry>
+
       <xi:include href="user-system-options.xml" xpointer="system" />
       <xi:include href="user-system-options.xml" xpointer="host" />
       <xi:include href="user-system-options.xml" xpointer="machine" />
diff --git a/src/run/run.c b/src/run/run.c
index bbb542b65b..df97641f87 100644
--- a/src/run/run.c
+++ b/src/run/run.c
@@ -60,6 +60,7 @@ static usec_t arg_on_unit_inactive = 0;
 static char *arg_on_calendar = NULL;
 static char **arg_timer_property = NULL;
 static bool arg_quiet = false;
+static bool arg_aggressive_gc = false;
 
 static void help(void) {
         printf("%s [OPTIONS...] {COMMAND} [ARGS...]\n\n"
@@ -84,6 +85,7 @@ static void help(void) {
                "     --setenv=NAME=VALUE          Set environment\n"
                "  -t --pty                        Run service on pseudo tty\n"
                "  -q --quiet                      Suppress information messages during runtime\n\n"
+               "  -G --collect                    Unload unit after it ran, even when failed\n\n"
                "Timer options:\n\n"
                "     --on-active=SECONDS          Run after SECONDS delay\n"
                "     --on-boot=SECONDS            Run SECONDS after machine was booted up\n"
@@ -153,6 +155,7 @@ static int parse_argv(int argc, char *argv[]) {
                 { "on-unit-inactive",  required_argument, NULL, ARG_ON_UNIT_INACTIVE },
                 { "on-calendar",       required_argument, NULL, ARG_ON_CALENDAR      },
                 { "timer-property",    required_argument, NULL, ARG_TIMER_PROPERTY   },
+                { "collect",           no_argument,       NULL, 'G'                  },
                 {},
         };
 
@@ -162,7 +165,7 @@ static int parse_argv(int argc, char *argv[]) {
         assert(argc >= 0);
         assert(argv);
 
-        while ((c = getopt_long(argc, argv, "+hrH:M:p:tq", options, NULL)) >= 0)
+        while ((c = getopt_long(argc, argv, "+hrH:M:p:tqG", options, NULL)) >= 0)
 
                 switch (c) {
 
@@ -329,6 +332,10 @@ static int parse_argv(int argc, char *argv[]) {
 
                         break;
 
+                case 'G':
+                        arg_aggressive_gc = true;
+                        break;
+
                 case '?':
                         return -EINVAL;
 
@@ -382,6 +389,12 @@ static int transient_unit_set_properties(sd_bus_message *m, char **properties) {
         if (r < 0)
                 return r;
 
+        if (arg_aggressive_gc) {
+                r = sd_bus_message_append(m, "(sv)", "CollectMode", "s", "inactive-or-failed");
+                if (r < 0)
+                        return r;
+        }
+
         STRV_FOREACH(i, properties) {
                 r = sd_bus_message_open_container(m, 'r', "sv");
                 if (r < 0)
