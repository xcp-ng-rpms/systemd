From 2f960b84dad97c50c819f2c11812fe6f302ec2ca Mon Sep 17 00:00:00 2001
From: Lennart Poettering <lennart@poettering.net>
Date: Thu, 6 Feb 2014 01:50:41 +0100
Subject: [PATCH] core: only send SIGHUP when doing first kill, not when doing
 final sigkill

Conflicts:
	src/core/unit.c

(cherry-picked from 97e0691f85da6e7ea131ce80bd61e2d47a737a61)

Resolves: #1147524
---
 src/core/unit.c | 20 ++++++++++++++++----
 1 file changed, 16 insertions(+), 4 deletions(-)

diff --git a/src/core/unit.c b/src/core/unit.c
index 855e135..fe1864a 100644
--- a/src/core/unit.c
+++ b/src/core/unit.c
@@ -3113,7 +3113,7 @@ int unit_kill_context(
                 } else {
                         wait_for_exit = !main_pid_alien;
 
-                        if (c->send_sighup)
+                        if (c->send_sighup && !sigkill)
                                 kill(main_pid, SIGHUP);
                 }
         }
@@ -3131,7 +3131,7 @@ int unit_kill_context(
                 } else {
                         wait_for_exit = true;
 
-                        if (c->send_sighup)
+                        if (c->send_sighup && !sigkill)
                                 kill(control_pid, SIGHUP);
                 }
         }
@@ -3149,8 +3149,20 @@ int unit_kill_context(
                         if (r != -EAGAIN && r != -ESRCH && r != -ENOENT)
                                 log_warning_unit(u->id, "Failed to kill control group: %s", strerror(-r));
                 } else if (r > 0) {
-                        wait_for_exit = true;
-                        if (c->send_sighup) {
+
+                        /* FIXME: Now, we don't actually wait for any
+                         * of the processes that are neither control
+                         * nor main process. We should wait for them
+                         * of course, but that's hard since the cgroup
+                         * notification logic is so unreliable. It is
+                         * not available at all in containers, and on
+                         * the host it gets confused by
+                         * subgroups. Hence, for now, let's not wait
+                         * for these processes -- but when the kernel
+                         * gets fixed we really should correct
+                         * that. */
+
+                        if (c->send_sighup && !sigkill) {
                                 set_free(pid_set);
 
                                 pid_set = unit_pid_set(main_pid, control_pid);
