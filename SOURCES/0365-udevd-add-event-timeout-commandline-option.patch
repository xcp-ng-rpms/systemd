From 3f13db324c715ab9dd0a514490160448ed3ae7ee Mon Sep 17 00:00:00 2001
From: Hannes Reinecke <hare@suse.de>
Date: Tue, 29 Jul 2014 09:06:14 +0200
Subject: [PATCH] udevd: add --event-timeout commandline option

Some events take longer than the default 30 seconds. Killing those
events will leave the machine halfway configured.

Add a commandline option '--event-timeout' to handle these cases.

(cherry-picked from 9719859c07aa13539ed2cd4b31972cd30f678543)

Conflicts:
	src/udev/udevd.c

Resolves: #1154778
---
 man/systemd-udevd.service.xml | 19 +++++++++++++++++++
 src/udev/udevd.c              | 14 ++++++++++++--
 2 files changed, 31 insertions(+), 2 deletions(-)

diff --git a/man/systemd-udevd.service.xml b/man/systemd-udevd.service.xml
index 7fce300..c3a2cb9 100644
--- a/man/systemd-udevd.service.xml
+++ b/man/systemd-udevd.service.xml
@@ -42,6 +42,7 @@
       <arg><option>--debug</option></arg>
       <arg><option>--children-max=</option></arg>
       <arg><option>--exec-delay=</option></arg>
+      <arg><option>--event-timeout=</option></arg>
       <arg><option>--resolve-names=early|late|never</option></arg>
       <arg><option>--version</option></arg>
       <arg><option>--help</option></arg>
@@ -90,6 +91,15 @@
         </listitem>
       </varlistentry>
       <varlistentry>
+        <term><option>--event-timeout=</option></term>
+        <listitem>
+          <para>Wait for the event to finish up to the given
+          number of seconds. After this time the event will
+          be terminated. Default is 30.</para>
+        </listitem>
+      </varlistentry>
+
+      <varlistentry>
         <term><option>--resolve-names=</option></term>
         <listitem>
           <para>Specify when systemd-udevd should resolve names of users and groups.
@@ -155,6 +165,15 @@
         </listitem>
       </varlistentry>
       <varlistentry>
+        <term><varname>udev.event-timeout=</varname></term>
+        <term><varname>rd.udev.event-timeout=</varname></term>
+        <listitem>
+          <para>Wait for events to finish up to the given number
+          of seconds. This option might be useful if events are
+          terminated due to a timeout in large configurations.</para>
+        </listitem>
+      </varlistentry>
+      <varlistentry>
         <term><varname>net.ifnames=</varname></term>
         <listitem>
           <para>Network interfaces are renamed to give them predictable names
diff --git a/src/udev/udevd.c b/src/udev/udevd.c
index 3d5feb4..6241549 100644
--- a/src/udev/udevd.c
+++ b/src/udev/udevd.c
@@ -72,6 +72,7 @@ static bool reload;
 static int children;
 static int children_max;
 static int exec_delay;
+static int event_timeout = 30;
 static sigset_t sigmask_orig;
 static UDEV_LIST(event_list);
 static UDEV_LIST(worker_list);
@@ -287,6 +288,9 @@ static void worker_new(struct event *event)
                         if (exec_delay > 0)
                                 udev_event->exec_delay = exec_delay;
 
+                        if (event_timeout != 30)
+                                udev_event->timeout_usec = event_timeout * USEC_PER_SEC;
+
                         /* apply rules, create node, symlinks */
                         udev_event_execute_rules(udev_event, rules, &sigmask_orig);
 
@@ -884,6 +888,8 @@ static void kernel_cmdline_options(struct udev *udev)
                         children_max = strtoul(opt + 18, NULL, 0);
                 } else if (startswith(opt, "udev.exec-delay=")) {
                         exec_delay = strtoul(opt + 16, NULL, 0);
+                } else if (startswith(opt, "udev.event-timeout=")) {
+                        event_timeout = strtoul(opt + 16, NULL, 0);
                 }
 
                 free(s);
@@ -903,6 +909,7 @@ int main(int argc, char *argv[])
                 { "debug", no_argument, NULL, 'D' },
                 { "children-max", required_argument, NULL, 'c' },
                 { "exec-delay", required_argument, NULL, 'e' },
+                { "event-timeout", required_argument, NULL, 't' },
                 { "resolve-names", required_argument, NULL, 'N' },
                 { "help", no_argument, NULL, 'h' },
                 { "version", no_argument, NULL, 'V' },
@@ -946,6 +953,9 @@ int main(int argc, char *argv[])
                 case 'e':
                         exec_delay = strtoul(optarg, NULL, 0);
                         break;
+                case 't':
+                        event_timeout = strtoul(optarg, NULL, 0);
+                        break;
                 case 'D':
                         debug = true;
                         log_set_max_level(LOG_DEBUG);
@@ -1278,8 +1288,8 @@ int main(int argc, char *argv[])
                                 if (worker->state != WORKER_RUNNING)
                                         continue;
 
-                                if ((now(CLOCK_MONOTONIC) - worker->event_start_usec) > 30 * 1000 * 1000) {
-                                        log_error("worker [%u] %s timeout; kill it\n", worker->pid,
+                                if ((now(CLOCK_MONOTONIC) - worker->event_start_usec) > event_timeout * USEC_PER_SEC) {
+                                        log_error("worker [%u] %s timeout; kill it", worker->pid,
                                             worker->event ? worker->event->devpath : "<idle>");
                                         kill(worker->pid, SIGKILL);
                                         worker->state = WORKER_KILLED;
